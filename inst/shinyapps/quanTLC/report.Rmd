---
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(dpi=300, cache=F,echo=F,warning=F,message=F,autodep=T)
library(knitr)
```

```{r Input,fig.width = 7,fig.height = 3.9}
dimension = reac$dimension

Cropping = dimension["Cropping [mm]",]
nbr.band=dimension["Number of bands",]
largeur = dimension["Plate length [mm]",]
dist.gauche=dimension["First application position [mm]",]
tolerance=dimension["Edge cut [mm]",]
band=dimension["Band length [mm]",]
ecart=dimension["Distance between tracks [mm]",]
width = dimension["Plate width [mm]",]
Zf = dimension["Migration front [mm]",]
dist.bas = dimension["Distance to lower edge [mm]",]
# cropping correction
largeur = largeur - 2 * Cropping
dist.gauche = dist.gauche - Cropping
if(input$Input_convention){ # this put everybody back to linomat convention
  dist.gauche<-dist.gauche-band/2
  ecart<-ecart-band
}
    
## Input image with ablines
if("Chromatogram" %in% input$Report_options){
  par(mar=c(0,0,2,0),xaxs="i",yaxs="i")
  raster(reac$image,xlim= c(0,200/largeur*dim(reac$image)[2]),main=if(is.null(input$Input_image)){"Demonstration file"}else{reac$image.name})
  
  abline(h=dim(reac$image)[1]/width*dist.bas)
  abline(h=dim(reac$image)[1]/width*Zf)
  for(i in c(0:(nbr.band-1))){
    abline(v=(dim(reac$image)[2]/largeur*((dist.gauche+tolerance)+i*(band+ecart))),col="green")
    abline(v=(dim(reac$image)[2]/largeur*((dist.gauche+band-tolerance)+i*(band+ecart))),col="red")
  }
}

## dimension table
if("Dimension table" %in% input$Report_options){
  kable(dimension, caption = 'Dimensions')
}
```


```{r Options}
## Preprocessing options
if("Preprocessing options" %in% input$Report_options && length(reac$Preprocess.order)>0){
    name <- c()
    value <- c()
    for(i in reac$Preprocess.order){
      if(i == 'Warping'){
        name <- c(name,i)
        value <- c(value,T)
        name <- c(name,names(reac$Preprocess.options[[i]]))
        value <- c(value,reac$Preprocess.options[[i]])
      }
      if(i == 'Standard.Normal.Variate'){
        name <- c(name,i)
        value <- c(value,T)
      }
      if(i == 'Negatif'){
        name <- c(name,"Negative peak inversion")
        value <- c(value,T)
      }
      if(i == 'medianFilter'){
        name <- c(name,i)
        value <- c(value,reac$Preprocess.options[[i]])
      }
      if(i == 'gammaCorrection'){
        name <- c(name,i)
        value <- c(value,reac$Preprocess.options[[i]])
      }
      if(i == 'Mean.centering'){
        name <- c(name,i)
        value <- c(value,T)
      }
      if(i == 'Autoscaling'){
        name <- c(name,i)
        value <- c(value,T)
      }
      if(i == 'Baseline.correction'){
        name <- c(name,i)
        value <- c(value,T)
        name <- c(name,names(reac$Preprocess.options[[i]]))
        value <- c(value,reac$Preprocess.options[[i]])
      }
      if(i == 'Smoothing'){
        name <- c(name,i)
        value <- c(value,T)
        name <- c(name,names(reac$Preprocess.options[[i]]))
        value <- c(value,reac$Preprocess.options[[i]])
      }
    }
    truc <- cbind(name, value)
    rownames(truc) <- seq(nrow(truc))
    kable(truc, caption = 'Preprocessing options',col.names = c("Name","Value"))
  }
## integration options
if("Integration options" %in% input$Report_options && length(reac$Integration_start) > 0){
  if(!reac$Integration_auto){
    width = reac$dimension["Plate width [mm]",]
    Zf = reac$dimension["Migration front [mm]",]
    dist.bas = reac$dimension["Distance to lower edge [mm]",]
    Integration_start = round(seq((width-dist.bas)/(Zf-dist.bas),-dist.bas/(Zf-dist.bas),length.out=dim(reac$preprocessed)[2])[mean(reac$Integration_start)],2)*100
    Integration_stop = round(seq((width-dist.bas)/(Zf-dist.bas),-dist.bas/(Zf-dist.bas),length.out=dim(reac$preprocessed)[2])[mean(reac$Integration_stop)],2)*100
    truc <- cbind(c("Automatic","Peak start [$\\textit{hR}_F$]","Peak end [$\\textit{hR}_F$]","Integration"), c(reac$Integration_auto,Integration_start,Integration_stop,paste0("Peak ",reac$Integration_mode)))
  }else{
    
  }
  rownames(truc) <- seq(nrow(truc))
  kable(truc, caption = 'Integration options',col.names = c("Name","Value"))
}

## stat options
if("Statistic options" %in% input$Report_options && !is.null(reac$model)){
  truc <- cbind(c("Regression","Channel"), c(reac$Stat_quadratic,reac$Stat_column))
  rownames(truc) <- seq(nrow(truc))
  kable(truc, caption = 'Statistic options',col.names = c("Name","Value"))
}
```


```{r chromato,fig.height=9.5,fig.width=7}

if("Video-densitograms" %in% input$Report_options && !is.null(reac$preprocessed)){
  ## before and after preprocess with integration boundaries after
  width = reac$dimension["Plate width [mm]",]
  Zf = reac$dimension["Migration front [mm]",]
  dist.bas = reac$dimension["Distance to lower edge [mm]",]
  nbr.band=reac$dimension["Number of bands",]
  par(mar=c(2.5,2.5,2,0),mgp=c(1.5,0.5,0),mfrow = c(if(nbr.band>=10){10}else{nbr.band},2),cex=0.6)
  for(i in seq(nbr.band)){
    f.plot.array(reac$extracted,id = i,
                 hauteur = width,Zf = Zf,dist.bas = dist.bas,reconstruct = T,main=paste0("Before preprocessing - Track ",i))
    f.plot.array(reac$preprocessed,id = i,
                 hauteur = width,Zf = Zf,dist.bas = dist.bas,reconstruct = F,main=paste0("After preprocessing - Track ",i))
    abline(v=reac$Integration_start[i],col="green")
    abline(v=reac$Integration_stop[i],col="red")
    abline(h=0)
  }
}
```

\tiny

```{r Integrations}
## batch

if("Batch" %in% input$Report_options && !is.null(reac$batch) ){
  kable(t(reac$batch), caption = 'Batch',align = "c",escape=F,row.names = T)
    # kable(reac$batch[,2:ncol(reac$batch)], caption = 'Batch',align = "c",escape=F,row.names = T)

}

```

\normalsize

```{r comment=NA}
## model summary
if("Model summary" %in% input$Report_options && !is.null(reac$model)){
  print(summary(reac$model))
    if(is.null(reac$model$model$`I(x^2)`)){
      truc = coef(summary(reac$model))
      cat(paste0("LOD: ",round(abs(3.3*truc[1,2]/truc[2,1]),4)," [AU]\n\n"))
      cat(paste0("LOQ: ",round(abs(10*truc[1,2]/truc[2,1]),4)," [AU]"))
    }else{
      cat("LOD and LOQ not available for quadratic models")
    }
}

```

```{r}
## calibration curve
if("Calibration curve" %in% input$Report_options && !is.null(reac$model)){
    data = data.frame(x=reac$batch[,"Quantity [AU]"],y=reac$batch[,reac$Stat_column])
    data$x[!reac$batch$Standard] = reac$batch[,"Prediction [AU]"][!reac$batch$Standard]
    data$x2=data$x^2
    data$y2 = data$y^2
    plot(x = data$x,y=data$y,xlab = "Quantity [AU]",ylab = reac$Stat_column,pch = 4,col=(!reac$batch$Standard)+1)
    # abline(reac$model)
    timevalues <- seq(min(data$y), max(data$y), by = abs(min(data$y) - max(data$y))/10)
    pred <- inversePredictCalibrate(reac$model,timevalues)[,2]
    lines(pred,timevalues)
}
```
