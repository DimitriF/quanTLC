---
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(dpi=300, cache=F,echo=F,warning=F,message=F,autodep=T,dev=c("pdf"))
library(knitr)
```

```{r Input,fig.width = 7,fig.height = 3.9}
dimension = reac$dimension

Cropping = dimension["Cropping",]
nbr.band=dimension["Number of band",]
largeur = dimension["Plate length",]
dist.gauche=dimension["First application position",]
tolerance=dimension["Edge cut",]
band=dimension["Band length",]
ecart=dimension["Distance between track",]
width = dimension["Plate width",]
Zf = dimension["Migration front",]
dist.bas = dimension["Distance to lower edge",]
# cropping correction
largeur = largeur - 2 * Cropping
dist.gauche = dist.gauche - Cropping
if(input$Input_convention){ # this put everybody back to linomat convention
  dist.gauche<-dist.gauche-band/2
  ecart<-ecart-band
}
    
## Input image with ablines
if("Chromatogram" %in% input$Report_options){
  par(mar=c(0,0,2,0),xaxs="i",yaxs="i")
  raster(reac$image,xlim= c(0,200/largeur*dim(reac$image)[2]),main=if(is.null(input$Input_image)){"Demonstration file"}else{input$Input_image$name})
  
  abline(h=dim(reac$image)[1]/width*dist.bas)
  abline(h=dim(reac$image)[1]/width*Zf)
  for(i in c(0:(nbr.band-1))){
    abline(v=(dim(reac$image)[2]/largeur*((dist.gauche+tolerance)+i*(band+ecart))),col="green")
    abline(v=(dim(reac$image)[2]/largeur*((dist.gauche+band-tolerance)+i*(band+ecart))),col="red")
  }
}

## dimension table
if("Dimension table" %in% input$Report_options){
  kable(dimension, caption = 'Dimension table')
}
```


```{r Options}
## Preprocessing options
if("Preprocessing options" %in% input$Report_options && length(reac$Preprocess.order)>0){
    name <- c()
    value <- c()
    for(i in reac$Preprocess.order){
      if(i == 'Warping'){
        name <- c(name,i)
        value <- c(value,T)
        name <- c(name,names(reac$Preprocess.options[[i]]))
        value <- c(value,reac$Preprocess.options[[i]])
      }
      if(i == 'Standard.Normal.Variate'){
        name <- c(name,i)
        value <- c(value,T)
      }
      if(i == 'Negatif'){
        name <- c(name,i)
        value <- c(value,T)
      }
      if(i == 'medianFilter'){
        name <- c(name,i)
        value <- c(value,reac$Preprocess.options[[i]])
      }
      if(i == 'gammaCorrection'){
        name <- c(name,i)
        value <- c(value,reac$Preprocess.options[[i]])
      }
      if(i == 'Mean.centering'){
        name <- c(name,i)
        value <- c(value,T)
      }
      if(i == 'Autoscaling'){
        name <- c(name,i)
        value <- c(value,T)
      }
      if(i == 'Baseline.correction'){
        name <- c(name,i)
        value <- c(value,T)
        name <- c(name,names(reac$Preprocess.options[[i]]))
        value <- c(value,reac$Preprocess.options[[i]])
      }
      if(i == 'Smoothing'){
        name <- c(name,i)
        value <- c(value,T)
        name <- c(name,names(reac$Preprocess.options[[i]]))
        value <- c(value,reac$Preprocess.options[[i]])
      }
    }
    truc <- cbind(name, value)
    rownames(truc) <- seq(nrow(truc))
    kable(truc, caption = 'Preprocessing Options')
  }
## integration options
if("Integration options" %in% input$Report_options && !is.null(reac$Integration_start)){
    width = reac$dimension["Plate width",]
    Zf = reac$dimension["Migration front",]
    dist.bas = reac$dimension["Distance to lower edge",]
    Integration_start = round(seq((width-dist.bas)/(Zf-dist.bas),-dist.bas/(Zf-dist.bas),length.out=dim(reac$preprocessed)[2])[reac$Integration_start],2)
    Integration_stop = round(seq((width-dist.bas)/(Zf-dist.bas),-dist.bas/(Zf-dist.bas),length.out=dim(reac$preprocessed)[2])[reac$Integration_stop],2)
  
  truc <- cbind(c("Integration_start","Integration_stop","Integration_mode"), c(Integration_start,Integration_stop,reac$Integration_mode))
  
  rownames(truc) <- seq(nrow(truc))
  kable(truc, caption = 'Integration Options')
}

## stat options
if("Statistic options" %in% input$Report_options && !is.null(reac$model)){
  truc <- cbind(c("Stat_quadratic","Stat_origin","Stat_column"), c(reac$Stat_quadratic,reac$Stat_origin,reac$Stat_column))
  rownames(truc) <- seq(nrow(truc))
  kable(truc, caption = 'Statistic Options')
}
```


```{r chromato,fig.height=9.5,fig.width=7}

if("Video-densitograms" %in% input$Report_options && !is.null(reac$preprocessed)){
  ## before and after preprocess with integration boundaries after
  width = reac$dimension["Plate width",]
  Zf = reac$dimension["Migration front",]
  dist.bas = reac$dimension["Distance to lower edge",]
  nbr.band=dimension["Number of band",]
  par(mar=c(2.5,2.5,2,0),mgp=c(1.5,0.5,0),mfrow = c(if(nbr.band>=10){10}else{nbr.band},2),cex=0.6)
  for(i in seq(nbr.band)){
    f.plot.array(reac$extracted,id = i,
                 hauteur = width,Zf = Zf,dist.bas = dist.bas,reconstruct = T,main=paste0("Before preprocessing - Track ",i))
    f.plot.array(reac$preprocessed,id = i,
                 hauteur = width,Zf = Zf,dist.bas = dist.bas,reconstruct = F,main=paste0("After preprocessing - Track ",i))
    abline(v=reac$Integration_start,col="green")
    abline(v=reac$Integration_stop,col="red")
  }
}
```

```{r Integrations}
## batch
if("batch" %in% input$Report_options && !is.null(reac$Integration_start)){
  kable(reac$batch, caption = 'Batch',align = "c")
}
## model summary
if("Model summary" %in% input$Report_options && !is.null(reac$model)){
  print(summary(reac$model))
    if(reac$Stat_quadratic == "linear"){
      print(paste0("LOD: ",lod(reac$model)[1]))
      print(paste0("LOQ: ",loq(reac$model)[1]))
    }else{
      print("LOD and LOQ not available for quadratic models")
    }
}
## calibration curve
if("Calibration curve" %in% input$Report_options && !is.null(reac$model)){
    data = data.frame(x=reac$batch[,"quantity [AU]"],y=reac$batch[,reac$Stat_column])
    data$x[!reac$batch$Standard] = reac$batch$prediction[!reac$batch$Standard]
    data$x2=data$x^2
    data$y2 = data$y^2
    plot(x = data$x,y=data$y,xlab = "quantity [AU]",ylab = reac$Stat_column,pch = 4,col=(!reac$batch$Standard)+1)
    # abline(reac$model)
    timevalues <- seq(min(data$y), max(data$y), 0.1)
    pred <- predict(reac$model,data.frame(y=timevalues, y2=timevalues^2))
    lines(pred,timevalues)
}
```
